<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-02-10T18:57:56+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 25: Fibonacci Digits]]></title>
    <link href="http://agam.github.io/blog/2015/02/10/euler-25-fibonacci-digits/"/>
    <updated>2015-02-10T18:43:52+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/10/euler-25-fibonacci-digits</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: spoilers ahead</p>

<p><em>Problem: find the first fibonacci number with 1000 digits</em></p>

<p>First though: hah, I can get the Nth fibonacci number in O(1) time!</p>

<p>```lisp
(defun fib (n)
  (let ((inv-sq-5 (/ 1 (sqrt 5)))</p>

<pre><code>(phi (/ (1+ (sqrt 5)) 2)))
(floor (+ 0.5 (* inv-sq-5 (expt phi n))))))
</code></pre>

<p>(defun digits (n)
  (round (1+ (log n 10))))</p>

<p>(defun log-fib-10 (n)
  (let ((log-10 (log 10))</p>

<pre><code>(log-phi (log (/ (1+ (sqrt 5)) 2)))
(log-k (log (/ 1 (sqrt 5)))))
(* log-10 (+ log-k (* n log-phi)))))
</code></pre>

<p>```</p>

<p>Nope, floating point numbers don&rsquo;t go beyond 308 digits or so</p>

<p><code>lisp
CL-USER&gt; most-positive-double-float
1.7976931348623157d308
</code></p>

<p>Perhaps there was a clever way to workaround this, but I wasn&rsquo;t feeling clever enough at the time. So, back to brute force.</p>

<p>```lisp
(defun fib (n)
  (cond ((= n 0) 0)</p>

<pre><code>((= n 1) 1)
(t (+ (fib (- n 1)) (fib (- n 2))))))
</code></pre>

<p>```</p>

<p>Well, this just takes <em>too long</em> (<code>(fib 40)</code> takes <code>3.883</code> seconds, and that has just 9 digits, so forget about anything bigger). Next step: memoization.</p>

<p>```lisp
(let ((memo-table (make-hash-table)))
  (defun memo-fib (n)</p>

<pre><code>(multiple-value-bind (hash-val exists) (gethash n memo-table)
  (if exists
  hash-val
  (let ((new-val (cond ((= n 0) 0)
                       ((= n 1) 1)
                       (t (+ (memo-fib (- n 1)) (memo-fib (- n 2)))))))
    (setf (gethash n memo-table) new-val)
    new-val)))))
</code></pre>

<p>(defun digits-num (n)
  (length (princ-to-string n)))
```</p>

<p>(yeah just to be even less clever, I get the digits by seeing the length of the string representation of the number &hellip; works)</p>

<p><code>(memo-fib 40)</code> is instantaneous, so is <code>(memo-fib 1000)</code>, and <code>(memo-fib 10000)</code> takes <code>3 ms</code>, so this should do it.</p>

<p>I used this to manually guess my way around and found the answer. Woohoo!</p>

<p>But this last part felt a bit &hellip; dirty, so before quitting this problem, I decided to automate it this way:</p>

<p>```lisp
(defun bin-search-range (fn target)
  (do<em> ((i 1 (</em> 2 i))</p>

<pre><code>   (val (funcall fn 1) (funcall fn i)))
   ((&gt;= val target) (values i (/ i 2)))
(format t "Debug: Trying (~A, ~A)~%" i val)))
</code></pre>

<p>(defun bin-search (fn low high target)
  (let* ((mid (round (/ (+ low high) 2)))</p>

<pre><code> (mid-val (funcall fn mid)))
(format t "Debug: Searching b/w (~A, ~A), found (~A, ~A)~%" low high mid mid-val)
(cond ((= high mid) mid)
  ((&gt;= mid-val target) (bin-search fn low mid target))
  ((&lt; mid-val target) (bin-search fn mid high target)))))
</code></pre>

<p>(defun solve (fn target)
  &ldquo;Two-phase search; first, exponentially increase argument until target is exceeded, then begin binary search with last argument&rdquo;
  (multiple-value-bind (high low) (bin-search-range fn target)</p>

<pre><code>(bin-search fn low high target)))
</code></pre>

<p>(defun target-function (n)
  (digits-num (memo-fib n)))</p>

<p>(defun euler-25 ()
  (solve #&lsquo;target-function 1000))
```</p>

<p>Yes, it does work. I left in my original debug statements (BTW the initial version had not one but <em>two</em> off-by-one errors! I learn slowly &hellip;), so the working is illustrated as follows:</p>

<p><code>lisp
CL-USER&gt; (euler-25)
Debug: Trying (1, 1)
Debug: Trying (2, 1)
Debug: Trying (4, 1)
Debug: Trying (8, 2)
Debug: Trying (16, 3)
Debug: Trying (32, 7)
Debug: Trying (64, 14)
Debug: Trying (128, 27)
Debug: Trying (256, 54)
Debug: Trying (512, 107)
Debug: Trying (1024, 214)
Debug: Trying (2048, 428)
Debug: Trying (4096, 856)
Debug: Searching b/w (4096, 8192), found (6144, 1284)
Debug: Searching b/w (4096, 6144), found (5120, 1070)
Debug: Searching b/w (4096, 5120), found (4608, 963)
Debug: Searching b/w (4608, 5120), found (4864, 1017)
Debug: Searching b/w (4608, 4864), found (4736, 990)
Debug: Searching b/w (4736, 4864), found (4800, 1003)
Debug: Searching b/w (4736, 4800), found (4768, 997)
Debug: Searching b/w (4768, 4800), found (4784, 1000)
Debug: Searching b/w (4768, 4784), found (4776, 998)
Debug: Searching b/w (4776, 4784), found (4780, 999)
Debug: Searching b/w (4780, 4784), found (4782, 1000)
Debug: Searching b/w (4780, 4782), found (4781, 999)
Debug: Searching b/w (4781, 4782), found (4782, 1000)
4782
</code></p>

<p>The whole thing took <code>6 ms</code>. Not bad, eh?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 24: Permutations, a long story]]></title>
    <link href="http://agam.github.io/blog/2015/02/08/euler-24-permutations/"/>
    <updated>2015-02-08T07:48:20+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/08/euler-24-permutations</id>
    <content type="html"><![CDATA[<p>(The fact that this turned out to be a long story is <em>ridiculous</em>, but perhaps it&rsquo;ll be useful to someone else)</p>

<p>The idea here is intuitive: given say <code>0</code>, <code>1</code> and <code>2</code>, we can immediately come up with the following orderings:</p>

<p><code>
012
021
102
120
201
210
</code></p>

<p>The problem here is to find the millionth permutation of <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>.</p>

<p>The first way is to <em>cheat</em> and work it out with pen-and-paper, upon which you soon realize that there are cycles for each set of numbers. E.g. for two numbers we would have 2 possible orderings (<code>01</code> and <code>10</code>), for three we have the ones shown above, etc, and this is because for <code>n</code> numbers we have <code>n!</code> combinations. Right, that&rsquo;s obvious. But the next step is to see that <em>within</em> each block of <code>n!</code>, there are <code>n</code> blocks of size <code>(n-1)!</code>, where the first digit is the same, which means we have a straightforward way of reducing the problem of size <code>n</code> to a problem of size <code>n-1</code>.</p>

<p>As an example, to find the fifth permutation in the example above, we would see that it involves two cycles of two digits each, and then halfway through a single cycle. So we can come up with the first digit being <code>2</code>, and the next digit being the second of the remaining digits (i.e. <code>1</code>), and we&rsquo;re finally left with <code>0</code>.</p>

<p>(<strong>Note</strong>: Argh &hellip; This sentence is wrong! But I didn&rsquo;t realize that until later)</p>

<p>So I wrote the code for this, and I used Ocaml because I&rsquo;m a complete n00b at it.</p>

<p>```ocaml
let rec fact n =
  if n = 0 then 1
  else n * fact (n &ndash; 1)</p>

<p>let perm_total = 1_000_000;;</p>

<p>let get_perm total index =
  let fact_index = fact index in
  total / (fact_index), total mod fact_index</p>

<p>let rec get_all_perms total index_size =
  let rec get_next_perm total index_size perm_list =</p>

<pre><code>if index_size = 0 then perm_list
else match get_perm total index_size with
 | p, new_total -&gt; get_next_perm new_total (index_size - 1) (p :: perm_list)
</code></pre>

<p>  in List.rev (get_next_perm total index_size [])</p>

<p>let rec digits_list n lst =
  if n = 0 then (0 :: lst)
  else digits_list (n &ndash; 1) (n :: lst)</p>

<p>let remove_digit digit lst =
  List.filter (fun x &ndash;> x &lt;> digit) lst</p>

<p>let rec get_next_perm_digit perm_list digit_list pdlist =
  if List.length perm_list = 0 then pdlist
  else let p = List.hd perm_list in</p>

<pre><code>   let d = List.nth digit_list p in
   get_next_perm_digit (List.tl perm_list) (remove_digit d digit_list) (d :: pdlist)
</code></pre>

<p>let rec get_perm_digits perm_list =
  let digits = digits_list (List.length perm_list) [] in
  List.rev (get_next_perm_digit perm_list digits [])</p>

<p>let euler24 = get_perm_digits (get_all_perms perm_total 9);;     <br/>
```</p>

<p>Yes, the names are terrible. Many of the started out as nested functions which I pulled into the top-level to test separately. Anyway, the point is &hellip; the answer was <strong>wrong</strong>.</p>

<p>Ok, I thought, I must&rsquo;ve screwed up in the <em>Ocaml-ness</em> of my solution. So I rewrote it thusly:</p>

<p>```lisp
(defun fact (n)
  (if (= n 1)</p>

<pre><code>  1
  (* n (fact (1- n)))))
</code></pre>

<p>(defparameter <em>total</em> 1000000)</p>

<p>(defun get-perm (total index)
  (let ((f (fact index)))</p>

<pre><code>(truncate total f)))
</code></pre>

<p>(defun get-next-perm (total index-size perm-list)
  (if (= index-size 0)</p>

<pre><code>  (cons 0 perm-list)
  (multiple-value-bind (p new_total)
  (get-perm total index-size)
(get-next-perm new_total (1- index-size) (cons p perm-list)))))
</code></pre>

<p>(defun get-all-perms (total index-size)
  (reverse (get-next-perm total index-size &lsquo;())))</p>

<p>(defun digits-list (n)
  (loop for i from 0 to n</p>

<pre><code>   collect i))
</code></pre>

<p>(defun get-next-perm-digit (perm-list digit-list p-d-list)
  (if (null perm-list)</p>

<pre><code>  p-d-list
  (let* ((p (first perm-list))
     (d (nth p digit-list)))
(get-next-perm-digit (rest perm-list)
             (remove d digit-list)
             (cons d p-d-list)))))
</code></pre>

<p>(defun get-perm-digits (perm-list)
  (let ((digits (digits-list (1- (length perm-list)))))</p>

<pre><code>(reverse (get-next-perm-digit perm-list digits '()))))
</code></pre>

<p>(defun euler-24 ()
  (get-perm-digits (get-all-perms <em>total</em> 9)))
```</p>

<p>The <em>same</em> answer popped out &mdash; which means I was successful at my translation &mdash; but it was still the wrong answer. In the initial few seconds of denial, I refreshed the Project Euler page and tried again. No luck.</p>

<p>Now it was time for desperate measures, so I came up with this brute force solution:</p>

<p>```lisp
(defun list->number (list)
  (reduce (lambda (x y) (+ (* x 10) y)) list))</p>

<p>(defun number->list (n)
  (do ((tempn n (floor (/ tempn 10)))</p>

<pre><code>   (digits '() (cons (mod tempn 10) digits)))
  ((= tempn 0) digits)))
</code></pre>

<p>(defun has-digits (n digit-list)
  (let ((nlist (number->list n)))</p>

<pre><code>(not (set-difference digit-list nlist))))
</code></pre>

<p>(defun brute-force-next-permutation (digit-list)
  (let ((n (list->number digit-list)))</p>

<pre><code>(do ((trynum (1+ n) (1+ trynum)))
((has-digits trynum digit-list) (number-&gt;list trynum))
  (format t "Trying ~A~%" trynum))))
</code></pre>

<p>```</p>

<p>&hellip;. which wasn&rsquo;t <em>quite</em> right either, since it skipped the leading zero in our lists. This one seemed to work:</p>

<p>```lisp</p>

<p>(defun add-num (digit-list)
  (let ((sum (1+ (first digit-list))))</p>

<pre><code>(if (&lt; sum 10)
(cons sum (rest digit-list))
(cons (mod sum 10) (add-num (rest digit-list))))))
</code></pre>

<p>(defun next-number (digit-list)
  (let ((revlist (reverse digit-list)))</p>

<pre><code>(nreverse (add-num revlist))))
</code></pre>

<p>(defun brute-force-next-permutation (digit-list)
  (do ((trynum (next-number digit-list) (next-number trynum)))</p>

<pre><code>  ((not (set-difference digit-list trynum)) trynum)))
</code></pre>

<p>(defun brute-force-nth-permutation (digit-list n)
  (do ((i 1 (1+ i))</p>

<pre><code>   (trynum digit-list (brute-force-next-permutation trynum)))
  ((= i n) trynum)))
</code></pre>

<p>```</p>

<p>So I set that running with <code>(brute-force-nth-permutation '(0 1 2 3 4 5 6 7 8 9) 1000000)</code>, and it looked like it was clearly going to take a while.</p>

<p>At this point I was really depressed, since I couldn&rsquo;t figure out <em>what</em> was wrong with the initial approach which was so <em>straightforward</em> &hellip; and then I realized that <strong>I was probably off by one</strong>.</p>

<p>So I took the answer submitted earlier, and entered the <em>next</em> permutation. Nope. Ok, what about the <em>previous</em> one? That worked!</p>

<p>(<strong>Note</strong>: To circle back to the &lsquo;trivial&rsquo; example at the top of the post: I didn&rsquo;t catch myself talking about the fifth permutation as being 0,1,2,3,4,5 &mdash; so I was really talking about the <em>sixth</em> permutation &hellip;)</p>

<p>Later, the (inefficient) brute-force computation terminated in <code>1668</code> seconds, and happily, the answers matched. I tried the previous code with a small modification:</p>

<p><code>lisp
(defun euler-24 ()
  (get-perm-digits (get-all-perms (1- *total*) 9)))
</code></p>

<p>&hellip; and it gave the same answer (and obviously, so did the Ocaml version). So a happy ending to this story, but a painful reminder of the fact that <strong>there are only two hard problems in computer science: naming, caching, and off-by-one errors.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 23: Non-abundant sums]]></title>
    <link href="http://agam.github.io/blog/2015/02/01/euler-23-non-abundant-sums/"/>
    <updated>2015-02-01T19:01:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/01/euler-23-non-abundant-sums</id>
    <content type="html"><![CDATA[<p>Had a slice of free time, so decided to look at the next problem. Here&rsquo;s the initial naive solution:</p>

<p><code>``haskell
divisors n = [x | x &lt;- [1 .. n-1], n</code>mod` x == 0]</p>

<p>isAbundant n = n &lt; (sum $ divisors n)</p>

<p>abundants n = filter isAbundant $ [1 .. n]</p>

<p>expressSum z nums = not $ null [(x,y) | x &lt;&ndash; nums, y &lt;&ndash; nums, x + y == z]</p>

<p>sumAbundants n =
  let a = abundants n in</p>

<pre><code>      sum $ filter (\x -&gt; not $ expressSum x a) [1 .. n]
</code></pre>

<p>```</p>

<p>While it gave the correct answer, it did so in <code>3133.33</code> seconds, which is &hellip; embarrassing.</p>

<p>This is just <em>too</em> inefficient, even the following &hellip;</p>

<p>```lisp
(defun divisors (n)
  (loop for i from 1 below n</p>

<pre><code> when (= 0 (mod n i))
   collect i))
</code></pre>

<p>(defun abundantp (n)
  (&lt; n</p>

<pre><code> (reduce #'+ (divisors n))))
</code></pre>

<p>(defun abundants (n)
  (loop for i from 1 below n</p>

<pre><code> when (abundantp i)
   collect i))
</code></pre>

<p>(defun possible-summands (z nums)
  (loop for x in nums do</p>

<pre><code>   (loop for y in nums
  when (= z (+ x y)) do
    (return-from possible-summands (cons x y)))))
</code></pre>

<p>(defun sum-abundants (n)
  (let* ((ab (abundants n))</p>

<pre><code> (summands 
  (loop for i from 1 to n
     when (null (possible-summands i ab))
     collect i)))
(reduce #'+ summands)))
</code></pre>

<p>```</p>

<p>&hellip; takes no less than half as long, at <code>1329.168</code> seconds.</p>

<p>BTW why is <code>28123</code> the upper limit for this sequence? I had no idea, and found <a href="http://mathschallenge.net/full/sum_of_two_abundant_numbers">this explanation</a> (and tangentially, <a href="http://mathschallenge.net/view/even_sum_of_two_abundant_numbers">this one</a> too).</p>

<p>Anyway, I&rsquo;m ashamed to say I didn&rsquo;t put in the effort to learn how to profile Haskell programs (<em>next time ?</em>) and profiled the Lisp version instead, which showed that (<strong>duh</strong>) all the time was going in finding divisors. Obviously, we can just loop till the <em>square root of N</em> instead of looping <em>all the way to N</em>. After this change:</p>

<p>```lisp
(defun divisors (n)
(declare (type fixnum n))
  (loop for i from 1 below (floor (sqrt n))</p>

<pre><code> when (= 0 (mod n i))
   collect i))
</code></pre>

<p>```</p>

<p>&hellip; it runs in <code>38 milliseconds</code> !!</p>

<p>And a similar change to the Haskell version:</p>

<p><code>haskell
divisors :: Int -&gt; [Int]
divisors n = [x | x &lt;- [1 .. round $ sqrt $ fromIntegral n], n `mod` x == 0]
</code></p>

<p>gave the expected answer in <code>180 milliseconds</code>. Not bad (though it should be noted we&rsquo;re still an order of magnitude away in efficiency).</p>

<p><strong>Notes:</strong></p>

<ul>
<li><p>Haskell makes it very easy to quickly arrive at a <em>correct</em> solution, but the road from there to an <em>efficient</em> solution is less clear.</p></li>
<li><p>The brevity of the notation helps, but I get a feeling it&rsquo;s also due to the single-letter variable names &mdash; which is all right (and indeed well-suited) for a tiny math problem, but unclear whether it&rsquo;ll hold up for code in a large-scale project.</p></li>
<li><p>People usually jump to the <a href="">&ldquo;Programming Language shootout&rdquo;</a>, but if the code <em>there</em> is any indication, writing performant Haskell code is a dark art, and <em>the three-line quicksort is a devilish honeytrap</em>.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 22: Scoring names ?]]></title>
    <link href="http://agam.github.io/blog/2015/02/01/euler-22-scoring-names/"/>
    <updated>2015-02-01T05:01:13+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/01/euler-22-scoring-names</id>
    <content type="html"><![CDATA[<p>This one seemed simple but turned out to be a good showcase for a short haskell program (I&rsquo;m sure it can be shorter but IMHO that would probably approach <em>Perl-ness</em>)</p>

<p>```haskell
import qualified Data.Char as C
import qualified Data.List as L
import qualified Debug.Trace as T</p>

<p>charValue c = C.ord (C.toUpper c) &ndash; C.ord &lsquo;A&rsquo; + 1</p>

<p>nameValue n = sum $ map charValue n</p>

<p>nameProduct (name, index) = index * nameValue name</p>

<p>splitString c s =
  case break (== c) s of</p>

<pre><code>   ([], _:xs) -&gt; [xs]
   (y, _:xs) -&gt; [y] ++ splitString c xs
   (xs, []) -&gt; [xs]
</code></pre>

<p>getNameSum f =</p>

<pre><code> let w = splitString ',' $ filter (/= '\"') f
 in
    T.traceShow (length w)
    sum $ map nameProduct $ zip (L.sort w) [1 .. ]
</code></pre>

<p>getNames fileName =
  do</p>

<pre><code> f &lt;- readFile fileName
 return $ getNameSum f
</code></pre>

<p>```</p>

<p>I left the `traceShow' in there to give an example of the debugging I relied upon. Other than that, it was enjoyable, and I really do appreciate how much longer this would have been in most other languages.</p>

<p><strong>Notes:</strong></p>

<ul>
<li><p>I skipped the part about <em>sorting</em> the input and spent a long time (<em>unnecessarily!</em>) complaining about the <em>black-boxness</em> of the &ldquo;IO&rdquo;</p></li>
<li><p>I suspected the initial version had an off-by-one error; luckily <code>awk</code> was on hand to sanity check the number of words:</p></li>
</ul>


<p><code>sh
$ cat /tmp/p022_names.txt | tr ',' ' ' | tr '"' ' ' | tr -s " " | awk 'BEGIN { RS = " " }; END { print NR }'
5163
</code></p>

<ul>
<li>Just to dump it out there, the <em>other</em> way of checking the soundness of the logic:</li>
</ul>


<p>```lisp
(defun char-value &copy;
  (1+ (&ndash; (char-code c)</p>

<pre><code> (char-code #\A))))
</code></pre>

<p>(defun string-value (str)
  (loop for c across (string-upcase str)</p>

<pre><code>   sum (char-value c)))
</code></pre>

<p>(defun name-product (name index)
  (* index</p>

<pre><code> (string-value name)))
</code></pre>

<p>(defun range (n)
  (loop for i from 1 to n</p>

<pre><code> collect i))
</code></pre>

<p>(defun sum-names (names)
  (reduce #&lsquo;+</p>

<pre><code>  (mapcar #'name-product
      names
      (range (length names)))))
</code></pre>

<p>```</p>

<p>&hellip; used (e.g.) as <code>(sum-names (list "foo" "bar"))</code></p>

<ul>
<li>For some reason, the code-formatter for Jekyll (<code>pygments</code>) is completely thrown off by the Haskell source above. Perhaps this post have been in &ldquo;literate code&rdquo;. Most likely it would have been procrastinated out of existence if attempted that way.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 21: Amicable numbers (in unamicable languages)]]></title>
    <link href="http://agam.github.io/blog/2015/01/31/euler-21-amicable-numbers/"/>
    <updated>2015-01-31T04:01:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/01/31/euler-21-amicable-numbers</id>
    <content type="html"><![CDATA[<p><em>Picking up where I left off, apparently 2 years ago !! :(</em></p>

<p>To avoid a procrastination excuse, I decided to skip the step of adding it to the github repo I had started earlier. Here is the raw, unedited form of the attempt at the next problem in my sequence, #21.</p>

<p><code>``haskell
isDiv a b = a</code>mod` b == 0</p>

<p>divisors n = [x | x &lt;&ndash; [1 .. n-1], isDiv n x]</p>

<p>&mdash; d(n) = sum of divisors of n
sumDiv n = sum $ divisors n</p>

<p>&mdash; a and b are &lsquo;amicable&rsquo; if d(a) = b, and d(b) = a
amicable a b = (a /= b) &amp;&amp; (sumDiv a == b) &amp;&amp; (sumDiv b == a)</p>

<p>&mdash; evaluate all pairs under 1000
&mdash; amicableUnder1000 = [(x,y) | x &lt;&ndash; [1 .. 999], y &lt;&ndash; [1 .. 999], amicable x y]
&mdash; euler21 = foldr ((x,y) &ndash;> x + y) 0  amicableUnder1000
```</p>

<p>This naive version was predictably going to take forever, so interrupted Ghci and decided to try a slightly different approach (to explicitly pre-evaluate the sums of divisors).</p>

<p>```haskell
sumDivNumbersUnder10000 = [sumDiv n | n &lt;&ndash; [1 .. 9999]]
sumDiv' n = sumDivNumbersUnder10000 !! (n-1)</p>

<p>amicable' (a,sa) (b,sb) = (a /= b) &amp;&amp; (sa == b) &amp;&amp; (sb == a)</p>

<p>amicableUnder10000 = [(x,y) | x &lt;&ndash; [1 .. 9999], y &lt;&ndash; [1 .. 9999], amicable' (x,sumDiv' x) (y, sumDiv' y)]
```</p>

<p>This version took <code>4.64</code> seconds in Ghci for the numbers less than 1000, at which point I realized the problem had actually called for the numbers less than <em>10000</em> instead. I left it running, out of curiosity, and it took <code>1758.96</code> seconds (not to mention a <em>prodigious</em> amount of memory: <code>97202052160</code> bytes!)</p>

<p>This done, the final answer was easy:</p>

<p><code>haskell
sum $ map fst amicableUnder10000
31626
</code></p>

<p>But this sort of gets to my problem with Haskell; I&rsquo;m never sure what&rsquo;s <em>really</em> going on, and how to make it do <em>what I want it to do</em>. On the other hand, I can feel an excess of &ldquo;imperative thinking&rdquo; is getting in the way (why isn&rsquo;t this as fast as a nested for loop?) Obviously, I need more time at this :)</p>

<p>Anyway, I tried yet another way towards this:</p>

<p>```haskell
partialAmicable x n = [(x,y) | y &lt;&ndash; [1 .. n-1], amicable' (x, sumDiv' x) (y, sumDiv' y)]</p>

<p>fullAmicable n = filter (not . null) (map f $ take n [1 ..])</p>

<pre><code>         where f x = partialAmicable x n
</code></pre>

<p>```</p>

<p>&hellip; which ran into <code>*** Exception: Prelude.(!!): index too large</code></p>

<p>At this point I realized that:</p>

<ul>
<li>I had no idea how to &lsquo;debug&rsquo; this (lacking a &lsquo;stack trace&rsquo;), but also</li>
<li>I was still dealing with <strong>lists</strong>, when I really wanted <strong>vectors</strong>.</li>
</ul>


<p>So I gave it one <em>final</em> shot:</p>

<p>```haskell
import Data.Vector as V</p>

<p>divSums n = V.fromList [sumDiv x | x &lt;&ndash; [1 .. n-1]]</p>

<p>amicables n = let ds = divSums n in</p>

<pre><code>              V.fromList [(x,y) | x &lt;- [1 .. n-1], y &lt;- [1 .. n-1], amicable' (x, ds ! (x-1)) (y, ds ! (y-1))]
</code></pre>

<p>```</p>

<p>&hellip; and this time, I got</p>

<p><code>haskell
Î»&gt; amicables 10000
fromList [(220,284),(284,220),(1184,1210),(1210,1184),(2620,2924),(2924,2620),(5020,5564),(5564,5020),(6232,6368),(6368,6232)]
(204.01 secs, 97203591888 bytes)
</code></p>

<p>Ok, I can stop here; perhaps <code>204</code> seconds of brute-forcing isn&rsquo;t all that bad?</p>

<p>Unfortunately, my &ldquo;comfort zone&rdquo; yielded this:</p>

<p>```lisp
(defun div (x y)
  (= (mod x y) 0))</p>

<p>(defun divisors (x)
  (loop for i from 1 below x</p>

<pre><code> when (div x i)
   collect i))
</code></pre>

<p>(defun sum-divs (x)
  (reduce #&lsquo;+ (divisors x)))</p>

<p>(defun pre-sum-divs (n)
  (let ((myarr (make-array n :element-type &lsquo;fixnum)))</p>

<pre><code>(loop for i from 1 below n
 do (setf (aref myarr i) (sum-divs i)))
myarr))
</code></pre>

<p>(defun amicablep (x sx y sy)
  (and (not (= x y))</p>

<pre><code>   (= sx y)
   (= sy x)))
</code></pre>

<p>(defun amicables (n)
  (let ((ds (pre-sum-divs n)))</p>

<pre><code>(loop for i from 1 below n do
 (loop for j from 1 below n
    when (amicablep i (aref ds i) j (aref ds j))
    do (print j)))))
</code></pre>

<p>```</p>

<p>which runs <em>just a little bit faster</em> (!!)</p>

<p>```lisp
CL-USER> (time (amicables 10000))</p>

<p>284
220
1210
1184
2924
2620
5564
5020
6368
6232
Evaluation took:
2.815 seconds of real time
2.820000 seconds of total run time (2.820000 user, 0.000000 system)
100.18% CPU
7,318,463,192 processor cycles
3,939,984 bytes consed
```</p>

<p>So this is my problem: I need to find a way to get my mental model of Haskell to perform at this speed (and clearly, it&rsquo;s two orders of magnitude off). It isn&rsquo;t going to be easy &hellip;</p>

<p><strong>EDIT</strong>: Make that just <em>one</em> order of magnitude.
It&rsquo;s possible for Ghci to use compiled object code instead of byte code, by entering <code>:set -fobject-code</code>.
After this, evaluating <code>amicables 10000</code> took <code>23.71</code> seconds.</p>
]]></content>
  </entry>
  
</feed>
